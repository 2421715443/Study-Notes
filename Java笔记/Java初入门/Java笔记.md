# Java笔记

## 1.Java基础

---

### 1.1 学习javadoc

---

未开始



### 1.2 编码风格

---

类名每个单词的首字母都要大写，这种风格别称作“驼峰风格”,而其他内容如——字段、方法、对象引用等，只是把第一个字母小写。例如：

```java
public class OneName{
    private int twoName
    public void threeName(int name){
       //实现 
    }
}
```



### 1.3 构造器

---

如果你没有创建构造器，编译器会为你自动创建一个默认构造器（无参构造器），如果你创建了，就不会生成。

与类名相同，可以用参数列表区分进行重载，构造器的调用可以出现在另一个构造器中，但只能出现一个，不允许出现第二个，同样也不允许在类中调用。

构造器的调用总是在基本类型被初始化之后，不论你为构造器定义何值，其运行都在成员初始化后，不论你愿不愿意相信成员的值都已经初始化，并在初始化后被构造器赋值或修改。

```java
public class Test{
    private int a;
    Test(int value){
        a=value;
    }
}
```



### 1.4 this关键字

---

可以把自身对象传入方法中



### 1.5 垃圾回收

---

finalize()方法可以在垃圾回收的时刻做一些事（一些重要的清理工作），finalize()可以释放在调用“本地方法”时创建的内存空间如malloc()，可以在finalize()中调用free()方法来释放它。

垃圾回收方式有

minor gc，major gc，full gc（以下方法应该是协同配合：）

> 标记——清扫
>
> 停止——复制

Java中

> 1. 对象可能不会被垃圾回收
> 2. 垃圾回收并不等于析构
> 3. 垃圾回收只与内存有关（应该是内存不足时）



### 1.6 抽象类

---

抽象类用abstract修饰

```java
abstract class xxx{
    //抽象类
}
```

抽象类不需要所有的类都是抽象的可以包含方法的实现，其不允许不完整的抽象类生成对象，如果想产生对象就要为其创建导出类，其到处类要实现抽象基类中所有的抽象方法，其导出类也可作为基类继承。



### 1.7 接口

---

接口用interface代替class，接口实现类要用implements修饰

```java
interface xxx{
    //接口描述
}

class xxx implements xxx{
    //接口实现类
}
```

其允许所有的方法都为抽象的，其只是一种描述“说明了所有实现类此接口的类看起来都像这个接口这样”，接口中之需要确定方法名、参数列表和返回值类型，剩下的是都交给实现它的类补充，其实现类就和普通的类一样可以被继承可以生成对象等。

接口之间可以通过继承来拓展接口

```java
interface aaa{
    void a();
}
interface bbb extends aaa{
    void b();
}
class ab implements bbb{
    public void a() {}
    public void b() {}
}

```



### 1.8 完全解耦

---

没学明白？？？？？？？？？？？？？？？？？？cao



### 1.9 Java多重继承

---

```java
interface aaa{
    void aaa();
    //此接口与class d中存在的方法签名相同
    void d();
}
interface bbb{
    void bbb();
}
interface ccc{
    void ccc();
}
class ddd{
    public void d() {}
}
class OneC extends ddd
    implements aaa,bbb,ccc{
    public aaa() {}
    public bbb() {}
    public ccc() {}
    //这里不实现void d()接口
}
public class C{
    //在生成对象时尽管void d()接口没有在实现类中实现，但却在实现类的基类中找到了该方法的实现
    OneC O = new OneC();
}
```



### 1.10 访问权限控制

---

了解包访问权限和三个权限关键字即可

> public
>
> protected
>
> private



### 1.11 复用类

---

#### 组合语法

只需将对象的引用放入新类中即可，初始化位置可以是：

1. 定义对象的地方，在构造器被调用之前就可被初始化
2. 在类构造器中
3. 在使用对象之前，惰性初始化
4. 使用实例初始化

#### 继承语法
所有的类都隐式继承Object，继承用关键字extends，如果xxx方法在子类中被重载了，那么用

super.xxx可以调用基类版本的xxx方法，同时，基类的初始化是从内向外扩散的，简单来说就是先初始化基类

#### 代理

在被代理的“基类”中创建代理方法，用基类对象调用基类的方法，其在被继承时旧可以隐藏基类的接口。

在导出类中重载方法时使用@Override注释时，如果你因写错了方法名而造成的错误时，程序会抛出异常，而不会认为此方法时在导出类中新加入的方法。



### 1.12 protracted关键字

---

如果你想让导出类操作基类中的private标记的元素，最好还是将其保持为private，然后在基类中通过protected的方法来控制继承者的访问权限，在导出类中操控protected方法更改private域内的元素。



### 1.13 向上转型

---

导出类可以说是基类的一种类型，当一个方法可以接受基类数据时，同样可以接受他所有导出类的引用，这就称之为向上转型。

在导出类向上转型时唯一可能的就是丢失方法，导出类至少具备基类中的方法，这就是未特殊声明的情况下仍允许向上转型的原因。

继承不是必须的，应当慎用这项技术，我们应当在需要向上转型时使用。



### 1.14 final关键字

---

final关键字修饰基本数据类型常量时，在定义时必须对其赋值

空白final是什么？？？

final方法可以确保基类中的方法在导出类中行为不变并不被覆盖。



### 1.15 初始化及类的加载

---

java的每个类都是一个独立的文件夹，类只有在被需要时才会被加载，或者说是在被初次使用时被加载，通常发生在创建一个类的第一个对象时，但是static域只会被初始化一次。



### 1.16 多态

---

再论向上转型：

